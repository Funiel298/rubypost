=> 
[[32m#<Post:0x00007fa52cf6f030[0m
  id: [34m[1m1[0m,
  post_title: [36m[1mnil[0m,
  post_message: [36m[1mnil[0m,
  created_at: Mon, 29 Apr 2024 18:09:02.652144000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 18:09:02.652144000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m,
 [32m#<Post:0x00007fa52d143ac8[0m
  id: [34m[1m2[0m,
  post_title: [31m[1m"[0m[31mhello world[0m[31m[1m"[0m,
  post_message: [31m[1m"[0m[31mthat is supposed to be first item here[0m[31m[1m"[0m,
  created_at: Mon, 29 Apr 2024 18:09:27.921134000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 20:43:27.759005000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m,
 [32m#<Post:0x00007fa52d143848[0m
  id: [34m[1m3[0m,
  post_title: [31m[1m"[0m[31mhello[0m[31m[1m"[0m,
  post_message: [31m[1m"[0m[31mwhats going on???\r\n[0m[31m[1m"[0m,
  created_at: Mon, 29 Apr 2024 18:10:03.920568000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 18:10:03.920568000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m,
 [32m#<Post:0x00007fa52d143708[0m
  id: [34m[1m4[0m,
  post_title: [31m[1m"[0m[31mhello[0m[31m[1m"[0m,
  post_message: [31m[1m"[0m[31mwhats going on???\r\n[0m[31m[1m"[0m,
  created_at: Mon, 29 Apr 2024 18:10:52.305577000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 18:10:52.305577000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m,
 [32m#<Post:0x00007fa52d1435c8[0m
  id: [34m[1m5[0m,
  post_title: [31m[1m"[0m[31mPPAP[0m[31m[1m"[0m,
  post_message:
   [31m[1m"[0m[31mI have a pen\r\nI have an apple\r\nAh\r\nApple pen\r\nI have a pen\r\nI have pineapple\r\nAh\r\nPineapple pen\r\nApple pen\r\nPineapple pen\r\nAh\r\nPen Pie Pineapple Apple Pen\r\nPen Pie Pineapple Apple Pen[0m[31m[1m"[0m,
  created_at: Mon, 29 Apr 2024 18:11:04.790884000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 21:05:15.090968000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m,
 [32m#<Post:0x00007fa52d143488[0m
  id: [34m[1m6[0m,
  post_title: [31m[1m"[0m[31m[1m"[0m,
  post_message: [31m[1m"[0m[31m[1m"[0m,
  created_at: Mon, 29 Apr 2024 18:42:50.183580000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 18:42:50.183580000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m,
 [32m#<Post:0x00007fa52d143348[0m
  id: [34m[1m7[0m,
  post_title: [31m[1m"[0m[31mi reALLY NEED BETTER ipad[0m[31m[1m"[0m,
  post_message:
   [31m[1m"[0m[31mthis post about my ipad which is very slow and has weak processor so i cant play clash of clans\r\n[0m[31m[1m"[0m,
  created_at: Mon, 29 Apr 2024 18:45:53.250181000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 18:45:53.250181000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m,
 [32m#<Post:0x00007fa52d143208[0m
  id: [34m[1m8[0m,
  post_title: [31m[1m"[0m[31mОбработка ошибок в web apps не должна быть такой сложной[0m[31m[1m"[0m,
  post_message:
   [31m[1m"[0m[31mЗачем?\r\nВ процессе работы с Go я столкнулся с ещё одной проблемой — обработкой ошибок в хендлерах. Как можно сделать этот процесс удобным и эффективным для 150+ обработчиков? Как обеспечить консистентность и поддержку при обработке ошибок?\r\n\r\nРазумеется, мои поиски палочки-выручалочки закончились ничем. Есть протокол RFS7807, есть библиотека, есть масса противоречивых статей - выбирай, но как будто чего-то не хватает... По существу статья ниже полностью не отвечает на мои вопросы, но в ней достаточно много примеров, и я думаю, она будет полезной. Это лишь повод/предложение поделиться вашими примерами успешных кейсов.\r\n\r\nСобственно, статья, приятного прочтения.\r\n\r\nError handling in Go web apps shouldn't be so awkward\r\nянварь 2024.\r\n\r\nПолезный патерн обработки ошибок для REST, gRPC, и остальных сервисов.\r\n\r\nЯ собираюсь описать алгоритм обработки ошибок, который показался мне довольно элегантным при написании REST, gRPC или других сервисов на GO.\r\nПри написании этого поста я преследовал три цели:\r\n\r\nОбъяснить паттерн, который я внедрил для нескольких клиентов, другим разработчикам, работающим со схожей кодовой базой;\r\n\r\nПродемонстрировать другим свой паттерн, чтобы они могли применить его в своих приложениях;\r\n\r\nПолучить фидбек. Это лучший паттерн, который вы видели? Есть ли в нем слабые стороны, которые можно улучшить?\r\n\r\nДля простоты все примеры будут частью REST API использующего HTTP код состояния. Но те же принципы могут быть использованы для gRPC или даже для CLI.\r\n\r\nПроблема\r\nПрежде чем я приступлю непосредственно к шаблону, давайте я покажу, что он заменяет, чтобы мы могли понять, что он призван решить.\r\n\r\nДавайте посмотрим на простой HTTP хендлер, использующий шаблон HandlerFunc стандартной библиотеки, который извлекает виджет из БД и возвращает его в формате JSON.\r\n\r\nfunc (s *Service) GetWidget(w http.ResponseWriter, r *http.Request) {\r\n\tif err := r.ParseForm(); err != nil {\r\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\r\n\t\treturn\r\n\t}\r\n\tid, err := strconv.Atoi(r.Form.Get(\"widget_id\"))\r\n\tif err != nil {\r\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\r\n\t\treturn\r\n\t}\r\n\twidget, err := s.db.GetWidget(id)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\thttp.Error(w, err.Error(), http.StatusNotFound)\r\n\t\t\treturn\r\n\t\t}\r\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\twidgetJSON, err := json.Marshal(widget)\r\n\tif err != nil {\r\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tw.Header.Set(\"Content-Type\", \"application/json\")\r\n\tw.Write(widgetJSON)\r\nХоть это и должен быть более менее реалистичный пример, он все равно немного упрощен в сравнении с тем, что я обычно нахожу на проде. В частности, я никогда не видел, чтобы http.error использовали в реальных сервисах. Вероятно, в вашем случае будет использоваться пользовательский формат ошибки, который позволит отобразить именно то, что вам нужно. Возможно, вы используете JSON-ответ с необходимым контекстом или определяете собственные коды ошибок, и так далее. Или, может быть, вы хотите отобразить ошибку в формате HTML. Каким бы ни был ваш вариант, я предполагаю, что в вашем приложении вы заменяете стандартную функцию http.Error() на более сложную. Это, вероятно, означает, что ваш код ещё более сложный и повторяющийся, чем пример, который я привёл выше.\r\n\r\nКроме того позвольте мне указать на несколько проблем, которые я вижу в коде выше:\r\n\r\nВ языке Go существует идиома, которая позволяет удобно обрабатывать ошибки: \"if err!= nil {return err}\". Однако в данном случае мы не можем воспользоваться этой идиомой, так как сигнатура HandlerFunc не предусматривает возврат ошибки. Вместо этого нам нужно для каждой ошибки: а) обработать её; б) отдельно вернуть результат.\r\n\r\nМы должны явно обрабатывать статус HTTP для каждой ошибки. Если у вас есть десятки или даже сотни обработчиков, это может стать проблемой. Здесь не применяется принцип DRY (Don't Repeat Yourself). В одном хендлере это не так критично. Но было бы неплохо иметь стандартный HTTP-статус для всех ошибок, например, 500 / Internal Server Error.\r\n\r\nЭтот обработчик должен беспокоиться о внутренних механизмах базы данных. В частности, он проверяет, получили ли мы ошибку sql.ErrNoRows. Обработчик HTTP не должен знать о бд. Это плохая тесная связанность, от которой мы можем избавиться.\r\n\r\nА что, если вместо этого...\r\nА что, если вместо этого:\r\n\r\nдля каждой ошибки мы могли бы просто `return err`, и все бы автоматически обработалось? Ошибка была бы отрендерена в правильном формате и отправлена пользователю?\r\n\r\nмагия, отвечающая за отображение ошибки, также знала бы правильный HTTP-статус ? 400 invalid input, 404 not found, 401 unauthorized access и так далее?\r\nхранилище данных, будь то база данных SQL, MongoDB или файловая система, просто сообщало бы нам \"эта ошибка означает, что не найдено\", и это могло бы автоматически преобразоваться в 404, вместо того чтобы обработчику были известны детали реализации?\r\n\r\nШаблон, который я собираюсь описать, дает нам все эти возможности. Более того, он позволяет использовать ряд других довольно мощных шаблонов. Я упомяну некоторые из них в конце, и, возможно, позже я напишу более подробно о некоторых из них (дайте знать, если вас это заинтересует)\r\n\r\nИдиоматическая обработка ошибок\r\nТри описанных мной типа поведения, которых мы хотим достичь, зависят от двух факторов. Первый из них — это «идиоматическая обработка ошибок». Нам необходимо иметь возможность просто возвращать ошибку в наших обработчиках. К сожалению, стандартная библиотека не поддерживает эту возможность. Однако некоторые сторонние фреймворки предоставляют такую функциональность. Самый популярный, с которым я знаком, - это labstack echo, чей HandlerFunc выглядит следующим образом:\r\n\r\ntype HandlerFunc func(c Context) error\r\nОднако, на мой взгляд, вам не следует использовать сложный фреймворк, например Echo, только ради удобства работы с примитивами обработки ошибок. Вы вполне можете создать их самостоятельно. Предлагаю вам простой шаблон функции адаптера, который вам в этом поможет:\r\n\r\n// customHandler преобразует обработчик, возвращающий ошибку, в стандартный http.HandlerFunc.\r\nfunc customHandler(f func(http.ResponseWriter, *http.Request) error) http.HandlerFunc {\r\n\treturn func(w http.ResponseWriter, r *http.Request) {\r\n\t\terr := f(w, r)\r\n\t\tif err != nil {\r\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError) // Погодите, только 500? Подробнее позже\r\n\t\t}\r\n\t}\r\n}\r\nС такой функцией адаптера наш предыдущий обработчик упрощается до:\r\n\r\nfunc (s *Service) GetWidget(w http.ResponseWriter, r *http.Request) error {\r\n\tif err := r.ParseForm(); err != nil {\r\n\t\treturn err\r\n\t}\r\n\tid, err := strconv.Atoi(r.Form.Get(\"widget_id\"))\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\twidget, err := s.db.GetWidget(id)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\twidgetJSON, err := json.Marshal(widget)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\tw.Header.Set(\"Content-Type\", \"application/json\")\r\n\tw.Write(widgetJSON)\r\n}\r\nРазумеется, это означает, что мы должны применить функцию адаптера при настройке маршрутов.\r\n\r\nmux.Handle(\"/widget\", customHandler(s.GetWidget))\r\nКонечно, мы также повлияли на работу этого эндпоинта. Теперь все ошибки классифицируются как 500. Мы обсудим это подробнее.\r\n\r\nНо сначала эксперимент, над которым я работаю\r\nПрежде чем мы начнем, я хочу упомянуть экспериментальную библиотеку, над которой я работаю, с надеждой, что она в конечном итоге может стать официальным предложением для стандартной библиотеки (хотя я считаю, что шансы на ее принятие невелики), чтобы расширить определение типа http.HandlerFunc и включить в него необязательное возвращаемое значение ошибки. Библиотека называется gitlab.com/flimzy/httpe, и она добавляет варианты WithError к http.Handler, http.HandlerFunc, ServeHTTP и связанным промежуточным обработчикам. Она основана на моем опыте работы с клиентами в течение многих лет, но теперь существует как самостоятельная библиотека для удобного включения, если вы захотите.\r\n\r\nЕсли вы решите использовать эту библиотеку, новая версия обработчика останется неизменной, но вместо вызова customHandler вы можете использовать:\r\n\r\nimport \"gitlab.com/flimzy/httpe\"\r\n\r\nmux.Handle(\"/widget\", httpe.ToHandler(s.GetWidget))\r\nОсновное преимущество использования библиотеки HTTPe перед созданием собственного кастомного хендлера заключается в том, что она предлагает поддержку мидлваров и позволяет смешивать стандартные хендлеры с хендлерами, поддерживающими ошибки. Это даёт возможность обрабатывать ошибки скрытым образом. Однако эта тема выходит за рамки данного обсуждения.\r\n\r\nКак обрабатывать различные HTTP-статусы\r\nВторой важный фактор, влияющий на улучшения, — это способ указания HTTP-статуса. Хотя новый шаблон хендлера упрощает обработку ошибок, он может нарушить её, обрабатывая все ошибки как ошибки с кодом 500 (Внутренняя ошибка сервера) или любым другим произвольным статусом, который вы установили в своей функции customHandler. Давайте исправим это.\r\n\r\nОшибки - это интерфейсы\r\nВспомним, что в Go тип ошибки - это тип интерфейса, определяемый как:\r\n\r\ntype error interface {\r\n\tError() string\r\n}\r\nЭто мощный инструмент, так как он позволяет нам создавать собственные типы ошибок. Мы можем расширить тип ошибки, чтобы добавить в него дополнительные методы в соответствии с нашими потребностями. Мы планируем воспользоваться этими возможностями и создать собственный тип ошибок, который будет включать HTTP-статус. Кроме того, мы хотим добавить метод для его извлечения. Для этого мы будем использовать простой пользовательский тип:\r\n\r\ntype statusError struct {\r\n\terror\r\n\tstatus int\r\n}\r\nТеперь это уже \"полный\" тип ошибки. Он уже удовлетворяет интерфейсу ошибки благодаря встраиванию типа error (таким образом, его методы становятся методами нашего типа). И он включает код состояния. Но нам нужно добавить еще несколько элементов, чтобы сделать его полным. Сначала давайте добавим метод Unwrap, чтобы позволить работать правильно функциям errors.Unwrap и связанным errors.Is и errors.As:[0m[31m[1m"[0m,
  created_at: Mon, 29 Apr 2024 20:18:37.497556000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 21:35:14.757272000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m,
 [32m#<Post:0x00007fa52d1430c8[0m
  id: [34m[1m9[0m,
  post_title: [31m[1m"[0m[31mthatr is testing case[0m[31m[1m"[0m,
  post_message: [31m[1m"[0m[31m5 km was great for this day[0m[31m[1m"[0m,
  created_at: Mon, 29 Apr 2024 20:52:29.411174000 UTC +00:00,
  updated_at: Mon, 29 Apr 2024 20:52:29.411174000 UTC +00:00,
  hashtags: [36m[1mnil[0m,
  image: [36m[1mnil[0m,
  author: [36m[1mnil[0m[32m>[0m]
